# DATA ANALYSIS

>约定：
>
>Python社区对一些常用模块采用了命名约定
>
>~~~~python
>import numpy as np
>import matplotlib.pylot as plt
>import pandas as pd
>~~~~



## 1. NumPy基础：数组与向量化计算

### 1.1 Numpy ndarray:多维数组对象

ndarray是Python中的一个快速、灵活的大型数据集容器。数组允许你使用类似于标量的操作语法在整块数据上进行数学计算。

每一个数组都有一个shape属性，用以表征数组每一维度的数量；每一个数组都有一个dtype属性，用来描述数组的数据类型：

~~~~jupyter
In []:data.shape
Out[]:(2,3)

In []:data.dtype
Out[]:dtype('float64')
~~~~

#### 1.1.1 生成ndarray

使用array可以简单地生成数组。array函数可以接收任意的序列型数组，生成一个新的包含传递数据的NumPy数组。

~~~~jupyter
In []:data1 = [6, 7.5, 8, 0, 1]
In []:arr1 = np.array(data1)
In []:arr1
Out[]:array([6, 7.5, 8, 0, 1])
~~~~

使用ndim和shape属性可以检查数组的维度：

~~~~jupyter
In []:arr2.ndim
Out[]:2

In []:arr2.shape
Out[]:(2,4)
~~~~

除了np.array，还有其他方法可以生成新数组。zeros可以一次性生成全0数组，ones可以一次性生成全1数组。empty可以创建一个没有初始化数值的数组。

arange是Python内建函数range的数组版：

~~~~jupyter
In []:np.arange(15)
Out[]:array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14])
~~~~

#### 1.1.2  ndarray的数据类型

数据类型，即是dtype，如1.1中。

#### 1.1.3 NumPy数组算数

数组的操作不需要进行for循环，这种特性被称之为*向量化*，任何两个等尺寸的数组之间的算数操作都应用了逐元素操作的方式。

带有标量计算的算术操作，会把计算参数传递给数组的每一个元素，这和数学的数组运算一样。

同尺寸的数组之间的比较，会产生一个bool值数组。，即在原数组每一位显示True或者False。

#### 1.1.4 基础索引与切片

**一维数组**类似于Python的列表：

~~~~NumPy
	  array([0,1,2,3,4,5,6,7,8,9])
In []:arr[5:8]
Out[]:array([5,6,7])  左闭右开
~~~~

**注意**：如果传入了一个数值给一个切片，例如array[5:8]=12,数值被传递给了整个切片，区别于Python的内建列表，数组的切片是原数组的*视图*。这意味着数据并不是被复制了，任何对于视图的修改都会被反应到原数组上。

~~~~NumPy
	  array([0,1,2,3,4,5,6,7,8,9])
In []:arr[5:8]=12
Out[]:array([0,1,2,3,4,12,12,12,8,9])
~~~~

一个重要实例：:arrow_down:

~~~~jupyter
In []:arr_slice = arr[5:8]
In []:arr_slice
Out[]:array([12,12,12])
 
In []:arr_slice[1] = 12345
In []:arr
Out[]:array([0,1,2,3,4,12,12345,12,8,9])
~~~~

:arrow_up: 和其他语言有很大的不同，其他的数组编程语言都急切地复制数据。这是由于NumPy被设计成适合处理非常大的数组，如果NumPy持续复制数据会引起很大的内存问题。

如果仍然想要一份数组切片的拷贝而不是一份视图的话，就需要显式地复制这个数组，使用arr[5:8].copy()



**二维数组**的操作类似于python

#### 1.1.4.1 数组的切片索引

实例：

~~~~jupyter
	  array([[1,2,3]
	  		 [4,5,6]
	  		 [7,8,9]])
In []:arr2d[:2, 1:]
Out[]:
array([[2,3]
	   [5,6]])
~~~~

arr2d[:2, 1:]表示选择数组前两行，后面的所有列元素。

#### 1.1.5 布尔索引

numpy.random中的randn函数可以生成一些随机正态分布的数据。

~~~~
data = np.random.randn(7,4)
In []:names = 'Bob'
Out[]:array([True,False,False,True,False,False,False],dtype=bool)

In []:data[names=='Bob']
Out[]:保留了data数组的第1和第4行。
~~~~

> **注意**如果要想达到Python中的and和or作用，请使用&和|来代替。



基于常识来设置布尔值数组的值也是可以的。将data中所有的负值设置为0，可以这样做：

~~~~
In []:data[data < 0] = 0
这样即可将data数组中数值小于0的数值设置为0
~~~~



#### 1.1.6 神奇索引

*神奇索引*是NumPy中的术语，用于描述使用整数数组进行数据索引。

假设有这样的数组：

~~~~
array([0,0,0,0]
	  [1,1,1,1]
	  [2,2,2,2]
	  [3,3,3,3]
	  [4,4,4,4]
	  [5,5,5,5]
	  [6,6,6,6]
	  [7,7,7,7])
In []:arr[[-3,-5,-7]]
Out[]:
array([5,5,5,5]
	  [3,3,3,3]
	  [1,1,1,1])
~~~~

> *神奇索引*与切片不同，它总是将数据复制到一个新的数组中。



#### 1.1.7 数组转置与换轴

**转置**是一种特殊的数据重组形式，可以返回底层数据的视图而不需复制任何内容。

数组拥有transpose方法，也有特殊的T属性：

> T 类似于数学中的转置符号

数组的T方法可以将数组转置，得到一个原数组的视图(将原数组转置再赋值给原数组？)。



计算矩阵内积可以使用np.dot

np.dot(arr.T, arr)表示计算数组arr与其转置的积。

对于更高维的数组，transpose方法可以接收包含轴编号的元组，用于置换轴：

~~~~
In []:arr = np.arange(16).reshape((2,2,4))
In []:arr
Out[]:
array([[0, 1, 2, 3],
	   [4, 5, 6, 7]],
	  [[8, 9,10,11],
	   [12,13,14,15]])
	   
In []:arr.transpose((1,0,2)) 0代表X轴，1代表Y轴，2代表Z轴，此语句代表将X和Y轴变换
Out[]:
array([[0, 1, 2, 3],
	   [8, 9,10,11]],
	  [[4, 5, 6, 7],
	   [12,13,14,15]])
~~~~

在这里，轴已经被重新排序，使得原先第二个轴变为第一个，原先的第一个轴变为第二个，最后一个轴没有改变。



使用**.T**进行转置是换轴的一个特殊案例。ndarray有一个swapaxes方法，该方法接收一对轴编号作为参数，并对轴进行调整用于重组数据。swapaxes返回的是数据的视图，而没有对数据进行复制。

~~~~
In []:arr
Out[]:
array([[0, 1, 2, 3],
	   [4, 5, 6, 7]],
	  [[8, 9,10,11],
	   [12,13,14,15]])
In []:arr.swapaxes(1,2)
Out[]:
array([[0, 4]
	   [1, 5]
	   [2, 6]
	   [3, 7]]
	  [[8,12]
	   [9,13]
	   [10,14]
	   [11,15]])
~~~~

### 1.2 通用函数：快速的逐元素组函数

>通用函数，也成为ufunc，是一种在数据中进行逐行操作的函数。某些简单函数接收一个或多个标量数值，并产生一个或多个标
>量结果，而通用函数就是对这些简单函数的向量化封装。

例：  
一元通用函数：aqrt和exp函数。
>见NumPy 4.2.ipynb

二元通用函数：add和maximum。
>见见NumPy 4.2.ipynb
numpy.maximum逐个元素地将x和y中的元素的最大值计算出来。

一些通用函数返回多个数组，比如modf，是Python内建函数divmod的向量化版本，返回一个浮点值数组的小数部分和整数部分。